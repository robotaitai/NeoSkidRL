<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeoSkidRL Dashboard</title>
    
    <!-- Google Fonts - Similar to Physical AI aesthetic -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Physical AI-inspired color scheme */
            --bg-primary: #0a0a0b;
            --bg-secondary: #111113;
            --bg-card: #18181b;
            --bg-card-hover: #1f1f23;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-success: #22c55e;
            --accent-danger: #ef4444;
            --accent-warning: #f59e0b;
            --border-color: #27272a;
            --gradient-primary: linear-gradient(135deg, #6366f1, #8b5cf6);
            --gradient-success: linear-gradient(135deg, #22c55e, #10b981);
            --gradient-danger: linear-gradient(135deg, #ef4444, #dc2626);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Animated background gradient */
        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                var(--bg-primary);
            z-index: -1;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo-icon {
            width: 48px;
            height: 48px;
            background: var(--gradient-primary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .logo h1 {
            font-size: 1.75rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        
        .logo span {
            color: var(--accent-primary);
        }
        
        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }
        
        .nav-tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .nav-tab:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }
        
        .nav-tab.active {
            background: var(--gradient-primary);
            border-color: transparent;
            color: white;
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }
        
        .card:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .card-title {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .card-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        /* Grid layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }
        
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }
        
        .grid-4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
        }
        
        @media (max-width: 1200px) {
            .grid-4 { grid-template-columns: repeat(2, 1fr); }
        }
        
        @media (max-width: 768px) {
            .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; }
        }
        
        /* Section titles */
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .section-title::before {
            content: '';
            width: 4px;
            height: 1.5rem;
            background: var(--gradient-primary);
            border-radius: 2px;
        }
        
        /* Reward Cards - The main feature */
        .reward-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.25rem;
            margin-bottom: 2rem;
        }
        
        .reward-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.25rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .reward-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--card-accent, var(--gradient-primary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .reward-card:hover {
            transform: translateY(-4px);
            border-color: var(--accent-primary);
            box-shadow: 0 20px 40px -15px rgba(99, 102, 241, 0.2);
        }
        
        .reward-card:hover::before {
            opacity: 1;
        }
        
        .reward-card.positive { --card-accent: var(--gradient-success); }
        .reward-card.negative { --card-accent: var(--gradient-danger); }
        
        .reward-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .reward-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            background: rgba(99, 102, 241, 0.15);
        }
        
        .reward-card.positive .reward-icon { background: rgba(34, 197, 94, 0.15); }
        .reward-card.negative .reward-icon { background: rgba(239, 68, 68, 0.15); }
        
        .reward-weight {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .reward-card.positive .reward-weight { color: var(--accent-success); }
        .reward-card.negative .reward-weight { color: var(--accent-danger); }
        
        .reward-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        .reward-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 1rem;
        }
        
        /* Weight bar visualization */
        .weight-bar {
            height: 6px;
            background: var(--bg-secondary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.75rem;
        }
        
        .weight-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .reward-card.positive .weight-fill { background: var(--gradient-success); }
        .reward-card.negative .weight-fill { background: var(--gradient-danger); }
        
        /* Formula display */
        .formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin-top: 0.75rem;
        }
        
        /* RL Concept Explainer */
        .rl-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 2rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            margin-bottom: 2rem;
        }
        
        .rl-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .rl-node:hover {
            border-color: var(--accent-primary);
            transform: scale(1.05);
        }
        
        .rl-node.active {
            border-color: var(--accent-primary);
            background: rgba(99, 102, 241, 0.1);
        }
        
        .rl-node-icon {
            font-size: 2rem;
        }
        
        .rl-node-label {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .rl-arrow {
            font-size: 1.5rem;
            color: var(--text-muted);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        /* Trajectory Canvas */
        .trajectory-container {
            position: relative;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            overflow: hidden;
        }
        
        #trajectoryCanvas {
            width: 100%;
            height: 500px;
            display: block;
        }
        
        .trajectory-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(17, 17, 19, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        
        .legend-item:last-child { margin-bottom: 0; }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }
        
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px -10px rgba(99, 102, 241, 0.5);
        }
        
        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--bg-card-hover);
        }
        
        /* File selector */
        .file-select {
            padding: 0.6rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 200px;
        }
        
        .file-select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        /* Stats display */
        .stat-cards {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 0.25rem;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .stat-card.success .stat-value { color: var(--accent-success); }
        .stat-card.danger .stat-value { color: var(--accent-danger); }
        .stat-card.warning .stat-value { color: var(--accent-warning); }
        
        /* Tooltip */
        .tooltip {
            position: relative;
        }
        
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 100;
            transition: all 0.2s ease;
            margin-bottom: 0.5rem;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Page sections */
        .page { display: none; }
        .page.active { display: block; }
        
        /* Animation classes */
        .fade-in {
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-up {
            animation: slideUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
        }
        
        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 1rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }
        
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .empty-state-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>
    
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">üöó</div>
                <h1>Neo<span>Skid</span>RL</h1>
            </div>
            <nav class="nav-tabs">
                <button class="nav-tab active" data-page="rewards">Rewards</button>
                <button class="nav-tab" data-page="trajectory">Trajectory</button>
                <button class="nav-tab" data-page="learn">Learn RL</button>
            </nav>
        </header>
        
        <!-- Rewards Page -->
        <div id="rewards-page" class="page active">
            <h2 class="section-title">Understanding Reward Shaping</h2>
            
            <p style="color: var(--text-secondary); margin-bottom: 2rem; max-width: 800px; line-height: 1.7;">
                Reward shaping is how we teach the agent <strong style="color: var(--text-primary)">what we want it to do</strong>. 
                Each reward term provides a signal - positive rewards encourage behaviors, negative rewards discourage them. 
                The weights control how much the agent cares about each aspect.
            </p>
            
            <div class="reward-grid" id="reward-cards">
                <!-- Reward cards will be inserted here by JavaScript -->
            </div>
            
            <div class="card fade-in" style="margin-top: 2rem;">
                <div class="card-header">
                    <h3 class="card-title">üí° How Rewards Work Together</h3>
                </div>
                <p style="color: var(--text-secondary); line-height: 1.7;">
                    The total reward at each step is: <code style="background: var(--bg-secondary); padding: 0.25rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace;">
                    R = Œ£ (weight √ó term)</code>
                    <br><br>
                    <strong style="color: var(--text-primary)">Key insight:</strong> The agent tries to maximize cumulative reward over an episode. 
                    If collision penalty (-50) outweighs progress reward (+15 per step), the agent learns to avoid collisions even if it means slower progress.
                </p>
            </div>
        </div>
        
        <!-- Trajectory Page -->
        <div id="trajectory-page" class="page">
            <h2 class="section-title">Trajectory Viewer</h2>
            
            <div class="stat-cards" id="trajectory-stats">
                <div class="stat-card success">
                    <div class="stat-value">-</div>
                    <div class="stat-label">Outcome</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">-</div>
                    <div class="stat-label">Episode Length</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">-</div>
                    <div class="stat-label">Total Reward</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">-</div>
                    <div class="stat-label">Max Speed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">-</div>
                    <div class="stat-label">Final Distance</div>
                </div>
            </div>
            
            <div class="trajectory-container">
                <canvas id="trajectoryCanvas"></canvas>
                <div class="trajectory-legend">
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #22c55e;"></div>
                        <span>Goal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #6366f1;"></div>
                        <span>Start</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #ef4444;"></div>
                        <span>Collision</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #f59e0b;"></div>
                        <span>Stuck</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot" style="background: #71717a;"></div>
                        <span>Obstacle</span>
                    </div>
                </div>
                <div class="controls">
                    <select class="file-select" id="trajectory-select">
                        <option value="">Select trajectory...</option>
                    </select>
                    <button class="btn btn-secondary" id="refresh-trajectories">
                        üîÑ Refresh
                    </button>
                    <input type="file" id="trajectory-file" accept=".json" style="display: none;">
                    <button class="btn btn-secondary" onclick="document.getElementById('trajectory-file').click()">
                        üìÇ Load Local
                    </button>
                    <button class="btn btn-primary" id="play-btn">‚ñ∂ Play</button>
                    <button class="btn btn-secondary" id="reset-btn">‚Ü∫ Reset</button>
                    <input type="range" id="playback-slider" min="0" max="100" value="0" 
                           style="flex: 1; accent-color: var(--accent-primary);">
                    <span id="playback-time" style="font-family: 'JetBrains Mono', monospace; color: var(--text-muted);">0 / 0</span>
                </div>
            </div>
        </div>
        
        <!-- Learn RL Page -->
        <div id="learn-page" class="page">
            <h2 class="section-title">Learn Reinforcement Learning</h2>
            
            <div class="rl-flow">
                <div class="rl-node" data-concept="agent">
                    <div class="rl-node-icon">ü§ñ</div>
                    <div class="rl-node-label">Agent</div>
                </div>
                <div class="rl-arrow">‚Üí</div>
                <div class="rl-node" data-concept="action">
                    <div class="rl-node-icon">üéÆ</div>
                    <div class="rl-node-label">Action</div>
                </div>
                <div class="rl-arrow">‚Üí</div>
                <div class="rl-node" data-concept="environment">
                    <div class="rl-node-icon">üåç</div>
                    <div class="rl-node-label">Environment</div>
                </div>
                <div class="rl-arrow">‚Üí</div>
                <div class="rl-node" data-concept="state">
                    <div class="rl-node-icon">üìä</div>
                    <div class="rl-node-label">State</div>
                </div>
                <div class="rl-arrow">‚Üí</div>
                <div class="rl-node active" data-concept="reward">
                    <div class="rl-node-icon">‚≠ê</div>
                    <div class="rl-node-label">Reward</div>
                </div>
            </div>
            
            <div id="concept-explanation" class="card fade-in">
                <div class="card-header">
                    <h3 class="card-title">‚≠ê Reward</h3>
                </div>
                <p style="color: var(--text-secondary); line-height: 1.8;">
                    The <strong style="color: var(--text-primary)">reward</strong> is a numerical signal that tells the agent 
                    how well it's doing. In NeoSkidRL, we use multiple reward terms to shape behavior:
                    <br><br>
                    ‚Ä¢ <strong style="color: var(--accent-success)">Positive rewards</strong> encourage desired behavior (reaching the goal, making progress)
                    <br>
                    ‚Ä¢ <strong style="color: var(--accent-danger)">Negative rewards</strong> discourage unwanted behavior (collisions, getting stuck)
                    <br><br>
                    The agent's goal is to learn a <em>policy</em> (decision-making strategy) that maximizes 
                    the total reward over time. This is the core of reinforcement learning!
                </p>
            </div>
            
            <div class="grid-2" style="margin-top: 2rem;">
                <div class="card slide-up">
                    <div class="card-header">
                        <h3 class="card-title">üìö Key Concepts</h3>
                    </div>
                    <ul style="color: var(--text-secondary); line-height: 2; list-style-position: inside;">
                        <li><strong style="color: var(--text-primary)">Policy:</strong> The agent's strategy for choosing actions</li>
                        <li><strong style="color: var(--text-primary)">Value Function:</strong> Expected future rewards from a state</li>
                        <li><strong style="color: var(--text-primary)">Exploration:</strong> Trying new actions to learn</li>
                        <li><strong style="color: var(--text-primary)">Exploitation:</strong> Using known good actions</li>
                        <li><strong style="color: var(--text-primary)">Episode:</strong> One complete attempt at the task</li>
                    </ul>
                </div>
                
                <div class="card slide-up" style="animation-delay: 0.1s;">
                    <div class="card-header">
                        <h3 class="card-title">üß† SAC Algorithm</h3>
                    </div>
                    <p style="color: var(--text-secondary); line-height: 1.8;">
                        NeoSkidRL uses <strong style="color: var(--text-primary)">Soft Actor-Critic (SAC)</strong>, a state-of-the-art 
                        algorithm for continuous control tasks.
                        <br><br>
                        SAC balances:
                        <br>
                        ‚Ä¢ <strong style="color: var(--accent-primary)">Maximizing reward</strong> (getting to the goal)
                        <br>
                        ‚Ä¢ <strong style="color: var(--accent-secondary)">Maximizing entropy</strong> (exploring different actions)
                        <br><br>
                        This makes it both effective and robust!
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Reward data
        const rewards = [
            {
                name: "Progress",
                icon: "üéØ",
                weight: 15.0,
                type: "positive",
                description: "Rewards the car for moving closer to the goal. This is the main dense signal that guides learning.",
                formula: "prev_dist - curr_dist",
                maxWeight: 20
            },
            {
                name: "Goal Bonus",
                icon: "üèÜ",
                weight: 100.0,
                type: "positive",
                description: "A big bonus when the car reaches the goal. Sparse but powerful - tells the agent 'this is what success looks like'.",
                formula: "+100 if success",
                maxWeight: 150
            },
            {
                name: "Heading",
                icon: "üß≠",
                weight: 2.0,
                type: "positive",
                description: "Rewards facing toward the goal. Helps the agent learn orientation matters, not just position.",
                formula: "cos(goal_angle)",
                maxWeight: 5
            },
            {
                name: "Velocity",
                icon: "üí®",
                weight: 0.4,
                type: "positive",
                description: "Rewards forward movement. Encourages the agent to actually drive rather than sit still.",
                formula: "vx_body / v_max",
                maxWeight: 2
            },
            {
                name: "Time",
                icon: "‚è±Ô∏è",
                weight: -0.005,
                type: "negative",
                description: "Small penalty each step to encourage efficiency. Too high and the agent rushes recklessly.",
                formula: "-0.005 per step",
                maxWeight: 0.05
            },
            {
                name: "Collision",
                icon: "üí•",
                weight: -50.0,
                type: "negative",
                description: "Heavy penalty for hitting obstacles. Must be balanced - too high and agent won't move, too low and it ignores safety.",
                formula: "-50 if collision",
                maxWeight: 100
            },
            {
                name: "Stuck",
                icon: "üö´",
                weight: -20.0,
                type: "negative",
                description: "Penalty for getting stuck (trying to move but not moving). Prevents the agent from spinning wheels uselessly.",
                formula: "-20 if stuck",
                maxWeight: 50
            },
            {
                name: "Near Goal Speed",
                icon: "üõë",
                weight: -1.0,
                type: "negative",
                description: "Penalty for approaching the goal too fast. Teaches the agent to slow down for a clean stop.",
                formula: "-speed if near goal",
                maxWeight: 5
            },
            {
                name: "Clearance",
                icon: "üìè",
                weight: 0.0,
                type: "negative",
                description: "Penalty for being too close to obstacles. Helps with safety but can cause timid behavior if too high.",
                formula: "-(d_safe - min_lidar)",
                maxWeight: 2
            },
            {
                name: "Smooth",
                icon: "„Ä∞Ô∏è",
                weight: 0.0,
                type: "negative",
                description: "Penalty for jerky control actions. Encourages smooth driving but can slow learning if too strong.",
                formula: "-||action - prev_action||",
                maxWeight: 1
            }
        ];
        
        // Render reward cards
        function renderRewardCards() {
            const container = document.getElementById('reward-cards');
            container.innerHTML = rewards.map((reward, index) => {
                const fillPercent = Math.min(100, (Math.abs(reward.weight) / reward.maxWeight) * 100);
                return `
                    <div class="reward-card ${reward.type === 'positive' ? 'positive' : 'negative'} slide-up" 
                         style="animation-delay: ${index * 0.05}s">
                        <div class="reward-header">
                            <div class="reward-icon">${reward.icon}</div>
                            <div class="reward-weight">${reward.weight >= 0 ? '+' : ''}${reward.weight}</div>
                        </div>
                        <h4 class="reward-name">${reward.name}</h4>
                        <p class="reward-description">${reward.description}</p>
                        <div class="formula">${reward.formula}</div>
                        <div class="weight-bar">
                            <div class="weight-fill" style="width: ${fillPercent}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show corresponding page
                const pageId = tab.dataset.page + '-page';
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');
            });
        });
        
        // RL Concept explainer
        const conceptExplanations = {
            agent: {
                title: "ü§ñ Agent",
                text: `The <strong>agent</strong> is the learner - in NeoSkidRL, it's the car's brain (a neural network).
                       The agent observes the environment and decides what actions to take. It learns from experience,
                       gradually improving its decision-making to maximize reward.`
            },
            action: {
                title: "üéÆ Action",
                text: `An <strong>action</strong> is what the agent does at each step. In NeoSkidRL, actions are:
                       <br><br>
                       ‚Ä¢ <strong>Linear velocity (v):</strong> How fast to go forward/backward [-1, 1]
                       <br>
                       ‚Ä¢ <strong>Angular velocity (œâ):</strong> How fast to turn left/right [-1, 1]
                       <br><br>
                       The agent outputs continuous values, not discrete choices - this is continuous control!`
            },
            environment: {
                title: "üåç Environment",
                text: `The <strong>environment</strong> is the world the agent interacts with. NeoSkidRL uses MuJoCo,
                       a physics simulator that models the car, obstacles, and arena with realistic physics.
                       <br><br>
                       The environment takes the agent's action, simulates physics, and returns the new state and reward.`
            },
            state: {
                title: "üìä State / Observation",
                text: `The <strong>state</strong> (or observation) is what the agent can see. In NeoSkidRL:
                       <br><br>
                       ‚Ä¢ <strong>LiDAR:</strong> 16 distance readings around the car
                       <br>
                       ‚Ä¢ <strong>Goal:</strong> Relative position and angle to the goal
                       <br>
                       ‚Ä¢ <strong>Velocity:</strong> Current speed and angular velocity
                       <br><br>
                       The agent uses this information to decide its next action.`
            },
            reward: {
                title: "‚≠ê Reward",
                text: `The <strong>reward</strong> is a numerical signal that tells the agent how well it's doing.
                       In NeoSkidRL, we use multiple reward terms to shape behavior:
                       <br><br>
                       ‚Ä¢ <strong style="color: var(--accent-success)">Positive rewards</strong> encourage desired behavior
                       <br>
                       ‚Ä¢ <strong style="color: var(--accent-danger)">Negative rewards</strong> discourage unwanted behavior
                       <br><br>
                       The agent learns a policy that maximizes total reward over time!`
            }
        };
        
        document.querySelectorAll('.rl-node').forEach(node => {
            node.addEventListener('click', () => {
                const concept = node.dataset.concept;
                const explanation = conceptExplanations[concept];
                
                // Update active state
                document.querySelectorAll('.rl-node').forEach(n => n.classList.remove('active'));
                node.classList.add('active');
                
                // Update explanation
                const container = document.getElementById('concept-explanation');
                container.innerHTML = `
                    <div class="card-header">
                        <h3 class="card-title">${explanation.title}</h3>
                    </div>
                    <p style="color: var(--text-secondary); line-height: 1.8;">
                        ${explanation.text}
                    </p>
                `;
            });
        });
        
        // Trajectory visualization
        class TrajectoryViewer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.data = null;
                this.currentStep = 0;
                this.isPlaying = false;
                this.playbackSpeed = 50; // ms per step
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Controls
                document.getElementById('play-btn').addEventListener('click', () => this.togglePlay());
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('playback-slider').addEventListener('input', (e) => {
                    if (this.data) {
                        this.currentStep = Math.floor(e.target.value / 100 * (this.data.trajectory.length - 1));
                        this.render();
                    }
                });
                
                // File loading
                document.getElementById('trajectory-file').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                this.loadData(JSON.parse(e.target.result));
                            } catch (err) {
                                console.error('Failed to parse trajectory file:', err);
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                
                this.renderEmpty();
            }
            
            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = 500;
                if (this.data) this.render();
                else this.renderEmpty();
            }
            
            renderEmpty() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.fillStyle = '#111113';
                ctx.fillRect(0, 0, w, h);
                
                ctx.fillStyle = '#71717a';
                ctx.font = '16px Space Grotesk';
                ctx.textAlign = 'center';
                ctx.fillText('Load a trajectory file to visualize', w/2, h/2 - 20);
                ctx.fillText('üìÇ Click "Load File" to browse', w/2, h/2 + 20);
            }
            
            loadData(data) {
                this.data = data;
                this.currentStep = 0;
                this.updateStats();
                this.render();
            }
            
            updateStats() {
                if (!this.data) return;
                
                const stats = document.getElementById('trajectory-stats').children;
                const outcome = this.data.outcome;
                const outcomeColors = {
                    success: 'success',
                    collision: 'danger',
                    stuck: 'warning',
                    timeout: ''
                };
                
                stats[0].className = `stat-card ${outcomeColors[outcome] || ''}`;
                stats[0].querySelector('.stat-value').textContent = outcome.charAt(0).toUpperCase() + outcome.slice(1);
                stats[1].querySelector('.stat-value').textContent = this.data.episode_length;
                stats[2].querySelector('.stat-value').textContent = this.data.total_reward.toFixed(1);
                
                const maxSpeed = Math.max(...this.data.trajectory.map(s => s.speed));
                stats[3].querySelector('.stat-value').textContent = maxSpeed.toFixed(2);
                
                const finalDist = this.data.trajectory[this.data.trajectory.length - 1].dist_to_goal;
                stats[4].querySelector('.stat-value').textContent = finalDist.toFixed(2) + 'm';
            }
            
            worldToCanvas(x, y) {
                const arena = this.data?.metadata?.arena_size || [6, 6];
                const padding = 50;
                const w = this.canvas.width - padding * 2;
                const h = this.canvas.height - padding * 2;
                
                const scale = Math.min(w / arena[0], h / arena[1]);
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                
                return {
                    x: cx + x * scale,
                    y: cy - y * scale,  // Flip Y
                    scale: scale
                };
            }
            
            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Background
                ctx.fillStyle = '#111113';
                ctx.fillRect(0, 0, w, h);
                
                if (!this.data) {
                    this.renderEmpty();
                    return;
                }
                
                const trajectory = this.data.trajectory;
                const metadata = this.data.metadata;
                
                // Draw arena bounds
                const arena = metadata.arena_size || [6, 6];
                const corner1 = this.worldToCanvas(-arena[0]/2, -arena[1]/2);
                const corner2 = this.worldToCanvas(arena[0]/2, arena[1]/2);
                
                ctx.strokeStyle = '#27272a';
                ctx.lineWidth = 2;
                ctx.strokeRect(corner2.x, corner2.y, corner1.x - corner2.x, corner1.y - corner2.y);
                
                // Grid
                ctx.strokeStyle = '#1f1f23';
                ctx.lineWidth = 1;
                for (let i = -Math.floor(arena[0]/2); i <= Math.floor(arena[0]/2); i++) {
                    const p = this.worldToCanvas(i, 0);
                    ctx.beginPath();
                    ctx.moveTo(p.x, corner2.y);
                    ctx.lineTo(p.x, corner1.y);
                    ctx.stroke();
                }
                for (let i = -Math.floor(arena[1]/2); i <= Math.floor(arena[1]/2); i++) {
                    const p = this.worldToCanvas(0, i);
                    ctx.beginPath();
                    ctx.moveTo(corner2.x, p.y);
                    ctx.lineTo(corner1.x, p.y);
                    ctx.stroke();
                }
                
                // Draw obstacles
                const obstacles = metadata.obstacles || [];
                ctx.fillStyle = '#3f3f46';
                ctx.strokeStyle = '#52525b';
                ctx.lineWidth = 2;
                for (const [xmin, ymin, xmax, ymax] of obstacles) {
                    const p1 = this.worldToCanvas(xmin, ymax);
                    const p2 = this.worldToCanvas(xmax, ymin);
                    ctx.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                    ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                }
                
                // Draw goal
                const goalXY = metadata.goal_xy || [2, 0];
                const goal = this.worldToCanvas(goalXY[0], goalXY[1]);
                
                // Goal glow
                const gradient = ctx.createRadialGradient(goal.x, goal.y, 0, goal.x, goal.y, 30);
                gradient.addColorStop(0, 'rgba(34, 197, 94, 0.3)');
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(goal.x, goal.y, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Goal marker
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(goal.x, goal.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#111113';
                ctx.font = 'bold 14px Space Grotesk';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('G', goal.x, goal.y);
                
                // Draw trajectory up to current step
                if (trajectory.length > 1) {
                    // Color based on speed
                    const maxSpeed = Math.max(...trajectory.map(s => s.speed), 0.1);
                    
                    for (let i = 1; i <= this.currentStep && i < trajectory.length; i++) {
                        const prev = trajectory[i - 1];
                        const curr = trajectory[i];
                        
                        const p1 = this.worldToCanvas(prev.x, prev.y);
                        const p2 = this.worldToCanvas(curr.x, curr.y);
                        
                        // Color by speed
                        const speedRatio = curr.speed / maxSpeed;
                        const hue = 260 - speedRatio * 60; // Purple to blue
                        ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
                
                // Draw collision/stuck markers
                for (let i = 0; i <= this.currentStep && i < trajectory.length; i++) {
                    const step = trajectory[i];
                    if (step.collision || step.stuck) {
                        const p = this.worldToCanvas(step.x, step.y);
                        ctx.fillStyle = step.collision ? '#ef4444' : '#f59e0b';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Draw current position
                if (this.currentStep < trajectory.length) {
                    const curr = trajectory[this.currentStep];
                    const p = this.worldToCanvas(curr.x, curr.y);
                    
                    // Car body
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(-curr.yaw);  // Negative because canvas Y is flipped
                    
                    // Car shape
                    ctx.fillStyle = '#6366f1';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);  // Front
                    ctx.lineTo(-10, 8);  // Back left
                    ctx.lineTo(-10, -8); // Back right
                    ctx.closePath();
                    ctx.fill();
                    
                    // Heading indicator
                    ctx.strokeStyle = '#fafafa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(20, 0);
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Draw start position
                const start = trajectory[0];
                const startP = this.worldToCanvas(start.x, start.y);
                ctx.fillStyle = '#6366f1';
                ctx.strokeStyle = '#818cf8';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(startP.x, startP.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Update slider
                document.getElementById('playback-slider').value = (this.currentStep / (trajectory.length - 1)) * 100;
                document.getElementById('playback-time').textContent = `${this.currentStep} / ${trajectory.length - 1}`;
            }
            
            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('play-btn').textContent = this.isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
                
                if (this.isPlaying) {
                    this.playLoop();
                }
            }
            
            playLoop() {
                if (!this.isPlaying || !this.data) return;
                
                this.currentStep++;
                if (this.currentStep >= this.data.trajectory.length) {
                    this.currentStep = 0;
                }
                
                this.render();
                setTimeout(() => this.playLoop(), this.playbackSpeed);
            }
            
            reset() {
                this.isPlaying = false;
                document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                this.currentStep = 0;
                this.render();
            }
        }
        
        // Trajectory list management
        class TrajectoryManager {
            constructor(viewer) {
                this.viewer = viewer;
                this.select = document.getElementById('trajectory-select');
                this.refreshBtn = document.getElementById('refresh-trajectories');
                
                this.select.addEventListener('change', () => this.onSelectChange());
                this.refreshBtn.addEventListener('click', () => this.fetchTrajectories());
                
                // Auto-fetch on load
                this.fetchTrajectories();
            }
            
            async fetchTrajectories() {
                this.select.innerHTML = '<option value="">Loading...</option>';
                
                try {
                    const response = await fetch('/api/trajectories');
                    if (!response.ok) throw new Error('Failed to fetch');
                    
                    const trajectories = await response.json();
                    
                    this.select.innerHTML = '<option value="">Select trajectory...</option>';
                    
                    if (trajectories.length === 0) {
                        this.select.innerHTML += '<option value="" disabled>No trajectories found</option>';
                        return;
                    }
                    
                    // Group by run_id
                    const grouped = {};
                    for (const t of trajectories) {
                        if (!grouped[t.run_id]) grouped[t.run_id] = [];
                        grouped[t.run_id].push(t);
                    }
                    
                    for (const [runId, items] of Object.entries(grouped)) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = runId;
                        
                        for (const t of items.slice(0, 20)) {  // Limit per group
                            const option = document.createElement('option');
                            option.value = t.filename;
                            const outcomeEmoji = {
                                success: '‚úÖ',
                                collision: 'üí•',
                                stuck: 'üö´',
                                timeout: '‚è±Ô∏è'
                            }[t.outcome] || '‚ùì';
                            option.textContent = `${outcomeEmoji} Ep ${t.episode_idx} | R: ${t.total_reward.toFixed(1)} | ${t.episode_length} steps`;
                            optgroup.appendChild(option);
                        }
                        
                        this.select.appendChild(optgroup);
                    }
                } catch (err) {
                    console.log('API not available, use local file loading');
                    this.select.innerHTML = '<option value="">Use "Load Local" button ‚ñ∂</option>';
                }
            }
            
            async onSelectChange() {
                const filename = this.select.value;
                if (!filename) return;
                
                try {
                    const response = await fetch(`/api/trajectory/${filename}`);
                    if (!response.ok) throw new Error('Failed to fetch trajectory');
                    
                    const data = await response.json();
                    this.viewer.loadData(data);
                } catch (err) {
                    console.error('Failed to load trajectory:', err);
                }
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            renderRewardCards();
            const viewer = new TrajectoryViewer('trajectoryCanvas');
            new TrajectoryManager(viewer);
        });
    </script>
</body>
</html>
